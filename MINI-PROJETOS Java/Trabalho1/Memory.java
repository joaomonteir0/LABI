/**
 * Parametric RAM Memory
 * @author skeleton by António Manuel Adrego da Rocha
 * 
 * @author João Pedro Ferreira Monteiro, 102690
 * @author Diogo Tomás Rebelo Couto, 104288
 * 
 * @version data
 */

public class Memory<T extends Comparable<T>>
{ 
	private T[] mem; // memory elements storage
	private int nelem; // number of elements stored actually in the memory

	/**
	* The constructor creates an empty memory with the given size.
	* @param pSize the size of the memory.
	* @throws NegativeArraySizeException if size is negative.
	*/
	@SuppressWarnings ("unchecked") // eliminate the warning generated by the cast
	public Memory (int pSize) throws NegativeArraySizeException
	{
		if (pSize < 1) throw new NegativeArraySizeException ("Wrong size");
		mem = (T[]) new Comparable[pSize];
		nelem = 0; // empty
	}

	/**
	* The method returns the size of the memory.
	* @return the size of the memory.
	*/
	public int getSize ()
	{
		return mem.length;
	}

	/**
	* The method returns the number of elements (nelem) stored in the memory.
	* @return the number of elements of the memory.
	*/ 
	public int getNElem ()
	{
		return nelem;
	}

	/**
	* The method returns the element in the given position of the memory.
	* @param pPos the position, an integer between {@code 0} and {@code nelem-1}.
	* @return the element in the given position of the memory.
	* @throws IndexOutOfMemoryException if the given position is invalid.
	*/ 
	public T getElement (int pPos) throws IndexOutOfMemoryException
	{
		if (pPos < 0 || pPos >= nelem)
			throw new IndexOutOfMemoryException ("Position out of the used part of the memory");
		return mem[pPos];
	}

	/**
	* The method changes the element in the given position of the memory.
	* @param pPos the position, an integer between {@code 0} and {@code nelem-1}.
	* @param pObject the element to store in the memory.
	* @throws NullPointerException if the element is invalid.
	* @throws IndexOutOfMemoryException if the given position is invalid.
	*/ 
	public void setElement (int pPos, T pObject) throws NullPointerException, IndexOutOfMemoryException
	{
		if (pObject == null) throw new NullPointerException ("Null element");
		if (pPos < 0 || pPos >= nelem)
			throw new IndexOutOfMemoryException ("Position out of the used part of the memory");
		mem[pPos] = pObject;
	}

	/**
	* The method checks if the memory is empty (0 elements stored).
	* @return  {@code true} if memory is empty, otherwise {@code false}.
	*/
	public boolean isEmpty ()
	{
		return nelem == 0;
	}

	/**
	* The method checks if the memory is full (total elements stored).
	* @return  {@code true} if memory is full, otherwise {@code false}.
	*/
	public boolean isFull ()
	{
		return nelem == mem.length;
	}

	/**
	* The method inserts a new element in the end of the memory if it is not full
	* and increases the number of stored elements.
	* @param pObject the element to store in the memory.
	* @throws NullPointerException if the element is invalid.
	* @throws MemoryFullException if the memory is full.
	*/
	public void insert (T pObject) throws NullPointerException, MemoryFullException
	{
		if (pObject == null) throw new NullPointerException ("Null element");
		if (isFull ()) throw new MemoryFullException ("Full memory");

		mem[nelem++] = pObject;
	}

	/**
	* The method inserts a new element in the given position of the memory if it is not full,
	* it shifts down the following elements and increases the number of stored elements.
	* @param pObject the element to store in the memory.
	* @param pos the position, an integer between {@code 0} and {@code nelem-1}.
	* @throws NullPointerException if the element is invalid.
	* @throws MemoryFullException if the memory is full.
	* @throws IndexOutOfBoundsException if the position is invalid.
	*/
	public void insertPos (T pObject, int pos) throws NullPointerException, MemoryFullException, IndexOutOfBoundsException
	{
		if (isFull ()) throw new MemoryFullException ("Full memory");
		if (pObject == null) throw new NullPointerException ("Null element");
		nelem++;
		// implement the method
		for(int i = 1; i < nelem-pos; i++){
			mem[nelem-i] = mem[nelem-i-1];
		}
		mem[pos] = pObject;
	}

	/**
	* The method removes and returns the last element of the memory if it is not empty
	* and decreases the number of stored elements.
	* @return the last element of the memory.
	* @throws MemoryEmptyException if the memory is empty.
	*/
	public T delete () throws MemoryEmptyException
	{
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");

		T object = mem[--nelem];
		mem[nelem] = null;
		return object;
	}

	/**
	* The method removes and returns the element in the given position of the memory if it is not empty,
	* it shifts up the following elements and decreases the number of stored elements.
	* @param pos the position, an integer i between {@code 0} and {@code nelem-1}.
	* @return the element in the given position of the memory.
	* @throws MemoryEmptyException if the memory is empty.
	* @throws IndexOutOfBoundsException if the position is invalid.
	*/
	public T deletePos (int pos) throws MemoryEmptyException, IndexOutOfBoundsException
	{
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		if(pos+1 >= mem.length) throw new IndexOutOfBoundsException ("Position out of the used part of the memory");

		// implement the method
		mem[pos] = mem[pos+1];
		for(int i = pos+1; i<nelem;i++){
			mem[i] = mem[i+1];
		}
		mem[nelem] = null;
		nelem--;
		return mem[pos];
	}

	/**
	* The method searchs and returns the position of the given element of the memory if it is not empty.
	* @param pObject the element to be searched in the memory.
	* @return the index of the element if it is stored in the memory, otherwise {@code -1}.
	* @throws NullPointerException if the element is invalid.
	* @throws MemoryEmptyException if the memory is empty.
	*/
	public int search (T pObject) throws NullPointerException, MemoryEmptyException
	{
		if (pObject == null) throw new NullPointerException ("Null element");
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		
		for (int i = 0; i < nelem; i++)
			if (mem[i].equals(pObject)) return i;
		return -1;
	}

	/**
	* The method returns the bigger element in the memory.
	* @return the bigger element in the memory.
	* @throws MemoryEmptyException if the memory is empty.
	*/ 
	public T biggerElement () throws MemoryEmptyException
	{
		// implement the method
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		T biggest = mem[0];
		for(int i = 1; i < nelem; i++){
			if(biggest.compareTo(mem[i]) < 0){
				biggest = mem[i];
			}
		}
		return biggest;
	}

	/**
	* The method returns the smaller element in the memory.
	* @return the smaller element in the memory.
	* @throws MemoryEmptyException if the memory is empty.
	*/ 
	public T smallerElement () throws MemoryEmptyException
	{
		// implement the method
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		T smaller = mem[0];
		for(int i = 1; i < nelem; i++){
			if(smaller.compareTo(mem[i]) > 0){
				smaller = mem[i];
			}
		}
		return smaller;
	}

	/**
	* The method returns a full/shallow copy of the memory.
	* @return the copy constructor.
	*/
	public Memory<T> copy () // shallow copy of the elements
	{
		Memory<T> copia = new Memory<T> (mem.length);
		copia.nelem = nelem;
		// implement the method
		for(int i = 0; i<nelem; i++){
			copia.mem[i] = mem[i];
		}

		return copia;
	}

	/**
	* The method removes all elements in the memory.
	* @throws MemoryEmptyException if the memory is empty.
	*/
	public void clear () throws MemoryEmptyException
	{
		// implement the method
		if (isEmpty ()) throw new MemoryEmptyException ("Empty memory");
		for(int i = 0; i<nelem; i++){
			mem[i] = null;
		}
		nelem = 0;

	}

	/**
	* The method creates a string representing the contents of the memory. 
	* preceded by a message and its size.
	* @return the string representing the memory elements.
	*/
 @Override
	public String toString ()
	{
		if (isEmpty ()) return "Empty Memory";
		String str = "Memory size " + mem.length + " with " + nelem + " elements\n";
		for (int i = 0; i < nelem; i++) str += mem[i].toString () + " ";
		return str;
	}

	/**
	* The method checks if two memories have the same capacity, size and elements.
	* Despite the elements can be in diferent places of the memories.
	* @param obj the object to be compared with that must be of memory kind.
	* @return  {@code true} if memories are the same or equal, otherwise {@code false}.
	*/
 @Override
	@SuppressWarnings ("unchecked")
	public boolean equals (Object obj)
	{
		if (this == obj) return true;
		
		Memory<T> mem = (Memory<T>) obj;

		if (this.getSize() != mem.getSize()) return false;
		if (this.getNElem() != mem.getNElem()) return false;
		
		int thisNElem = this.getNElem();
		int memNElem = mem.getNElem();
		for (int i = 0; i < thisNElem; i++)
		{
			boolean found = false;

			for (int j = 0; j < memNElem; j++)	
				try
				{
					if (this.mem[i].equals (mem.getElement (j))) { found = true; break; }
				}
				catch (IndexOutOfMemoryException e) {  }

			if (!found) return false;
		}
		return true;
	}
}
